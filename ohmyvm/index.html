<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Playground</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            background-color: #f0f0f0;
            margin: 0;
        }
        #editor, #bytecode-editor {
            width: 80%;
            height: 150px;
            margin-bottom: 20px;
            border: 1px solid #ccc;
            padding: 10px;
            font-family: monospace;
        }
        #output, #execution-output {
            width: 80%;
            height: 100px;
            border: 1px solid #ccc;
            padding: 10px;
            background-color: #fff;
            font-family: monospace;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
        }
    </style>
</head>
<body>
    <textarea id="editor" placeholder="Enter the code here..."></textarea>
    <button onclick="compileCode()">Compile</button>
    <div id="output" placeholder="Generated bytecode..."></div>
    <textarea id="bytecode-editor" placeholder="Paste the bytecode here for execution..."></textarea>
    <button onclick="executeBytecode()">Execute Bytecode</button>
    <div id="execution-output" placeholder="Execution output..."></div>

    <script>
        const regs = ["r0", "r1", "r2", "r3", "r4", "r5"];
        const OP_PUSH = 1;
        const OP_POP = 2;
        const OP_SUM = 3;
        const OP_SUB = 4;
        const OP_SYSCALL = 5;
        const OP_PUSHSTR = 6;
        const OP_PUSHREG = 7;
        const OP_GET = 8;
        const OP_LABEL = 9;
        const OP_JMP = 10;
        const OP_INTSET = 11;
        const OP_PUSHVAR = 12;

        function compileCode() {
            const code = document.getElementById('editor').value;
            const lines = code.split('\n');
            let bytecode = [];
            let variables = [];

            lines.forEach(line => {
                if (line.startsWith("ipush ")) {
                    const value = parseInt(line.split(" ")[1]);
                    bytecode.push(OP_PUSH);
                    bytecode.push(value);
                } else if (line.startsWith("pop ")) {
                    const reg = line.split(" ")[1].trim();
                    if (regs.includes(reg)) {
                        bytecode.push(OP_POP);
                        bytecode.push(reg.length);
                        bytecode = bytecode.concat(Array.from(new TextEncoder().encode(reg)));
                    } else {
                        alert(`Error: unknown register: ${reg}`);
                    }
                } else if (line === "sum") {
                    bytecode.push(OP_SUM);
                } else if (line === "sub") {
                    bytecode.push(OP_SUB);
                } else if (line === "syscall") {
                    bytecode.push(OP_SYSCALL);
                } else if (line.startsWith("spush ")) {
                    const str = line.substring(6).replace("\\n", "\n").replace("\\s", " ");
                    bytecode.push(OP_PUSHSTR);
                    bytecode.push(str.length);
                    bytecode = bytecode.concat(Array.from(new TextEncoder().encode(str)));
                } else if (line.startsWith("rpush ")) {
                    const reg = line.split(" ")[1];
                    if (regs.includes(reg)) {
                        bytecode.push(OP_PUSHREG);
                        bytecode.push(reg.length);
                        bytecode = bytecode.concat(Array.from(new TextEncoder().encode(reg)));
                    }
                } else if (line.startsWith("get ")) {
                    const reg = line.split(" ")[1];
                    if (regs.includes(reg)) {
                        bytecode.push(OP_GET);
                        bytecode.push(reg.length);
                        bytecode = bytecode.concat(Array.from(new TextEncoder().encode(reg)));
                    }
                } else if (line.endsWith(":")) {
                    const labelname = line.split(":")[0].trim();
                    bytecode.push(OP_LABEL);
                    bytecode.push(labelname.length);
                    bytecode = bytecode.concat(Array.from(new TextEncoder().encode(labelname)));
                } else if (line.startsWith("jmp ")) {
                    const labelname = line.split(" ")[1];
                    bytecode.push(OP_JMP);
                    bytecode.push(labelname.length);
                    bytecode = bytecode.concat(Array.from(new TextEncoder().encode(labelname)));
                } else if (line === "lend") {
                    bytecode.push(...Array.from(new TextEncoder().encode("lend")));
                } else if (line.startsWith("iset ")) {
                    const parts = line.split(" ");
                    const name = parts[1].split(",")[0].replace(/["']/g, "").trim();
                    const value = parseInt(parts[1].split(",")[1].replace(/["']/g, "").trim());
                    variables.push(name);
                    bytecode.push(OP_INTSET);
                    bytecode.push(name.length);
                    bytecode = bytecode.concat(Array.from(new TextEncoder().encode(name)));
                    bytecode = bytecode.concat(Array.from(new Uint8Array(new Uint32Array([value]).buffer)));
                } else if (line.startsWith("vpush")) {
                    const name = line.split(" ")[1];
                    if (variables.includes(name)) {
                        bytecode.push(OP_PUSHVAR);
                        bytecode.push(name.length);
                        bytecode = bytecode.concat(Array.from(new TextEncoder().encode(name)));
                    } else {
                        alert(`Error: unknown variable -> ${name}`);
                    }
                }
            });

            document.getElementById('output').innerText = bytecode.join(" ");
        }

        function executeBytecode() {
            const bytecode = document.getElementById('bytecode-editor').value.split(' ').map(Number);
            const regs = { "r0": 0, "r1": 0, "r2": 0, "r3": 0, "r4": 0, "r5": 0 };
            const variables = {};
            const labels = {};
            let stack = new Array(20).fill(0);
            const in_label = [false];

            function execute2(bytecode) {
                let ip = 0;
                let sp = [0];
                let output = '';

                while (ip < bytecode.length) {
                    const byte = bytecode[ip];
                    ip += 1;

                    if (sp[0] > stack.length - 1) {
                        output += "Warning: stack overflow\n";
                        sp[0] -= 1;
                    } else if (sp[0] < 0) {
                        output += "Warning: stack underflow\n";
                        sp[0] += 1;
                    }

                    if (byte === OP_PUSH) {
                        const value = bytecode[ip];
                        ip += 1;
                        stack[sp[0]] = value;
                        sp[0] += 1;
                    } else if (byte === OP_POP) {
                        const reglen = bytecode[ip];
                        ip += 1;
                        const regname = new TextDecoder().decode(new Uint8Array(bytecode.slice(ip, ip + reglen)));
                        ip += reglen;
                        sp[0] -= 1;
                        regs[regname] = stack[sp[0]];
                        stack[sp[0]] = 0;
                    } else if (byte === OP_SUM) {
                        if (sp[0] >= 2) {
                            sp[0] -= 1;
                            const a = stack[sp[0]];
                            stack[sp[0]] = 0;
                            sp[0] -= 1;
                            const b = stack[sp[0]];
                            stack[sp[0]] = b + a;
                            sp[0] += 1;
                        } else {
                            output += "Warning: you need to have 2 items or more inside the stack to do sum\n";
                        }
                    } else if (byte === OP_SUB) {
                        if (sp[0] >= 2) {
                            sp[0] -= 1;
                            const a = stack[sp[0]];
                            stack[sp[0]] = 0;
                            sp[0] -= 1;
                            const b = stack[sp[0]];
                            stack[sp[0]] = b - a;
                            sp[0] += 1;
                        } else {
                            output += "Warning: you need to have 2 items or more inside the stack to do sub\n";
                        }
                    } else if (byte === OP_SYSCALL) {
                        if (regs["r0"] === 1) {
                            output += regs["r1"];
                            regs["r0"] = 0;
                            regs["r1"] = 0;
                        }
                    } else if (byte === OP_PUSHSTR) {
                        const strlen = bytecode[ip];
                        ip += 1;
                        const value = new TextDecoder().decode(new Uint8Array(bytecode.slice(ip, ip + strlen)));
                        ip += strlen;
                        stack[sp[0]] = value;
                        sp[0] += 1;
                    } else if (byte === OP_PUSHREG) {
                        const strlen = bytecode[ip];
                        ip += 1;
                        const reg = new TextDecoder().decode(new Uint8Array(bytecode.slice(ip, ip + strlen)));
                        stack[sp[0]] = regs[reg];
                        ip += strlen;
                        sp[0] += 1;
                    } else if (byte === OP_GET) {
                        const reglen = bytecode[ip];
                        ip += 1;
                        const reg = new TextDecoder().decode(new Uint8Array(bytecode.slice(ip, ip + reglen)));
                        ip += reglen;
                        regs[reg] = prompt("Enter input for register " + reg);
                    } else if (byte === OP_JMP) {
                        const namelen = bytecode[ip];
                        ip += 1;
                        const labelname = new TextDecoder().decode(new Uint8Array(bytecode.slice(ip, ip + namelen)));
                        ip += namelen;
                        execute2(labels[labelname]);
                        break;
                    } else if (byte === OP_INTSET) {
                        const namelen = bytecode[ip];
                        ip += 1;
                        const name = new TextDecoder().decode(new Uint8Array(bytecode.slice(ip, ip + namelen)));
                        ip += namelen;
                        const value = new DataView(new Uint8Array(bytecode.slice(ip, ip + 4)).buffer).getUint32(0, false);
                        ip += 4;
                        variables[name] = value;
                    } else if (byte === OP_PUSHVAR) {
                        const namelen = bytecode[ip];
                        ip += 1;
                        const name = new TextDecoder().decode(new Uint8Array(bytecode.slice(ip, ip + namelen)));
                        ip += namelen;
                        stack[sp[0]] = variables[name];
                        sp[0] += 1;
                    }
                }

                document.getElementById('execution-output').innerText = output;
            }

            function execute1(bytecode) {
                let ip = 0;
                const labelname = [""];

                while (ip < bytecode.length) {
                    const byte = bytecode[ip];
                    ip += 1;

                    if (!in_label[0]) {
                        if (byte === OP_LABEL) {
                            const namelen = bytecode[ip];
                            ip += 1;
                            const name = new TextDecoder().decode(new Uint8Array(bytecode.slice(ip, ip + namelen)));
                            ip += namelen;
                            labels[name] = [];
                            labelname[0] = name;
                            in_label[0] = true;
                        }
                    } else if (in_label[0]) {
                        if (byte === 108 && bytecode[ip] === 101 && bytecode[ip + 1] === 110 && bytecode[ip + 2] === 100) {
                            in_label[0] = false;
                            ip += 3;
                        } else {
                            labels[labelname[0]].push(byte);
                        }
                    }
                }

                execute2(labels["main"]);
            }

            if (bytecode.length === 0) {
                alert("Error: no bytecode provided");
                return;
            }

            execute1(bytecode);
        }
    </script>
</body>
</html>
